# üëæ Day 4/180 of The DeveloperProMax Challenge
> Coding, is Meditation

- Author: [Kintsugi-Programmer](https://github.com/kintsugi-programmer)

> Disclaimer: The content presented here is a curated blend of my personal learning journey, experiences, open-source documentation, and invaluable knowledge gained from diverse sources. I do not claim sole ownership over all the material; this is a community-driven effort to learn, share, and grow together.

- üìö Learn DSA, LeetCode, Web Dev, DevOps, and Core CS (OS, CN, DBMS, OOP, SD). 
- ‚öôÔ∏è Build. Deploy. Dominate.

- ‚òë DSA 1.5 hrs
- ‚òë Dev 1.5 hrs
- ‚òë LeetCode 1‚Äì2 questions
- ‚òë Core CS 1 hr
- ‚òë Revision 1 hr
- ‚òë Workout 1 hr

> Reflections: It's been a tough week balancing the joy of the festive season with family against tight college deadlines. Despite the packed schedule, I'm happy I was able to push through, making some progress on LeetCode with depth and keeping up with my other subjects.
> After reflecting on my goals, I've decided it's time to pivot. I'm now shifting to a focused sprint dedicated to practical Data Structures and Algorithms.
> My new game plan: üîπ Sprint through the Neetcode 75 list for practical problem-solving. üîπ Reinforce concepts with Neetcode's DSA Visualization course. üîπ Level up with their Advanced DSA Course. üîπ Sharpen my focus on interview-specific CS topics.
> To make this possible, I'm temporarily pausing web development and deeper theoretical DSA studies. Time to focus and build momentum!
> #DSA #LeetCode #ComputerScience #InterviewPrep #StudentLife #Strategy #Neetcode

> Developer Pro Max is a 180-day journey to elite developer mastery. From Advanced DSA and Core CS to Full-Stack Web Development, DevOps, and System Design, this challenge is designed to build discipline, depth, and real-world skills. Every day is a step toward becoming a developer who doesn‚Äôt just code, but engineers systems, solves problems, and commands the full stack with confidence.

‚ÄúBuild like a mortal. Think like a god.‚Äù

> Resources: Abdul Bari's Mastering Data Structures & Algorithms using C and C++, ChaiCode's Full Stack Web Dev Course with 100xDev's Cohort 3.0, NeetCode 250 DSA Sheet, and Research Docs &YT for Core CS , keeping focus on Revision, Health, Fitness & bit Gaming.

---
# CN
# Computer Networks World | in NutShell

## Computer Networks Fundamentals and Context

### Introduction and Subject Scope

**Computer Networks** is considered a lighter subject compared to Operating Systems (OS). There are only a few fundamental things that need to be known, and understanding these will allow most questions to be answered.

Networks are more important than subjects like Compilers or Computer Organization and Architecture (COA) because networks are essentially the **backbone of the internet today**.

Key topics covered include:
*   The network stack.
*   How actual data transfers happen hop-to-hop.
*   Understanding the ARP protocol, routing tables, MAC address tables, and how sender/receiver tables are populated.
*   How data packets travel and how headers are changed.

### Transition from Operating Systems (OS)

Previously, `OS` was discussed as sitting on the computer and` working as a program manager`. OS manages everything, including:
*   How processes and functions interact.
*   How code gets executed and reaches the core.
*   Managing memory and writing things to disk.

The understanding built around `OS was that it handles everything internally within the computer`.

### The Need for the Internet

People desired more features and wanted to create **the Internet**, allowing computers and things on the globe to connect.

The requirement was to run programs on *some other computer* and receive the results in one's own browser, rather than just running programs compiled and executed on the same computer. This requirement led to the development of ideas on how to support these connections.
![alt text](image-2.png)
Key questions that arose included:
1.  How does the data travel across the network?
2.  How to design independent pieces of software (like Chrome browser or server software).

A common interview question is: **"How does the Internet work?"** or specific details like, **"When you type google.com, how is that served?"**.

## Client-Server Model and Basic Flow
![alt text](image-3.png)
### Defining Client and Server

**Client** 
- A computer or entity 
- where the browser is running, 
- which 
  - **raises a request to view a page**
  - & **receives the result**.

*   Generally, **anything that starts the process** is the client.
*   The client requests a resource or data.

A **Server processes the request sends a response**.
*   A **Web Server** specifically processes HTTP/HTTPS requests received over the internet.
*   Servers can exist for other contexts as well.

### Protocols and Data Packets

People defined certain **Protocols**.
*   A `protocol is like a language needed to communicate`.
*   Protocols are a fixed set of rules.

What is sent on the internet is called **Data Packets**.
*   Anything traveling on the internet is called a data packet.

An example of a protocol is **HTTP** (Hypertext Transfer Protocol). When a user types a URL (e.g., `www.google.com`), an HTTP request is made following the protocol and sent onto the internet.

### Basic Request/Response Flow (HTTP)
![alt text](image-4.png)
1.  The client types a URL (e.g., `www.google.com`).
2.  The client sends an **HTTP request** onto the Internet.
3.  The request travels to the server where the backend/server code resides.
4.  The server reads the HTTP request, processes it, and generates an **HTTP response**.
5.  The HTTP response travels back across the Internet.
6.  The client's browser receives the data and displays it on the web page.
![alt text](image-5.png)
The fundamental challenge in this flow is **how the data travels magically across the internet**.

## Addressing Systems

### The Need for Addressing

Since many computers and web servers (which are also just computers running specific software) are connected to the Internet, a way to know where to send the data is required.

Just like ordering food requires an address for pickup (restaurant) and delivery (user), **some sort of addressing system must be built**.
![alt text](image-6.png)
### **IP Addresses (Computer Identification)**

The required address is known as the **IP Address** (Internet Protocol Address).

Every computer on the internet has an IP Address.
*   Example format: `192.168.1.1`.
*   **IPv4** (Fourth Version of IP) uses numbers separated by dots, generally using 256 numbers possible for each segment.

If a computer's IP address is known, one can type it into the browser to reach that address (e.g., trying to open `8.8.8.8` which is Google‚Äôs Public DNS https://dns.google/ ).
![alt text](image-7.png)
### **Ports (Application Identification)**

There is a need for a **two-phase addressing system**:
1.  Which computer should the response go to (IP Address).
2.  Inside that computer, which application/window should receive the response (Port).

Different applications run on different ports within a computer.
*   Example: A web server might be hosted at a specific IP address and a specific port.
*   **HTTP** by default uses port **80**. Web servers typically open at port 80.

### DNS (Domain Name System)

IP addresses are not fixed, or if they are fixed, knowing a new computer's IP address is difficult. People built simpler systems to help identify resources.

People rely on **Domain Names** (e.g., `google.com`).

![alt text](image.png)

#### DNS Resolution Process
DNS acts like a **phone book system**.
*   It is a **function that takes a domain name and converts it to its corresponding IP address**.
*   This process is necessary because **IP addresses can change dynamically**.

When a request is made:
1.  The request first goes to the **DNS Resolver**, usually owned by the Internet Service Provider (ISP).
2.  The DNS Resolver checks its **cache**.
![alt text](image-8.png)
#### Caching Mechanisms
*   The DNS Resolver has its own cache to save recently resolved domain names.
*   A **TTL** (Time To Live) defines how long a record stays in the cache. If the same domain (e.g., `example.com`) is asked repeatedly within the TTL, the cached result is returned directly.
*   Caching is implemented at every level (user application, PC, DNS Resolver).
*   When space limits caching, the **LRU (Least Recently Used)** eviction policy is typically used.

#### Hierarchical Structure
If a domain (e.g., `www.example.com`) is new and not in the cache, the DNS Resolver uses a hierarchical structure:
1.  It asks the **DNS Root Name Server** for the Name Server of the Top-Level Domain (TLD), e.g., `.com`.
2.  The Root Server returns the Name Server for the TLD.
3.  The Resolver then asks the TLD Name Server (e.g., the `.com` Name Server) for the name server managing `example.com`.
4.  The TLD Name Server returns the IP address of the **Authoritative Name Server** (often hosted by services like AWS Route 53 or GoDaddy) that knows the final IP address.
5.  The hosting service (e.g., GoDaddy) registers the domain with the TLD name server.

#### Name Records
DNS involves specific record types, such as:
*   **A Records** (Address Records).
*   **C Name Records** (Canonical Name Records).
*   *Note: Detailed understanding of DNS records is often not required in general interviews*.

If multiple IP addresses are returned for a domain (e.g., two addresses for a website), generally any one can be connected to.

## High-Level Internet Picture

The "Internet" symbol (the globe) is often the **biggest piece of illusion** for developers, as the actual data travel path is complex.
![alt text](image-9.png)
### Infrastructure Components

When a request is sent, the flow includes:
1.  **DNS resolution** (Root Name Server, TLD, etc.).
2.  An **HTTP request** is made.
3.  **TCP/IP magic** happens.
4.  The request goes through **Load Balancers**.
5.  The request reaches **Application Servers**.
6.  The response travels back.

All these pieces (Load Balancers, Firewalls, Servers) are built using either hardware or software, and all can be coded. Algorithms are used, for example, in Load Balancer code.

![alt text](image-1.png)

---
# DSA_LEETCODE

### 4 Two Sum [Easy]
- https://leetcode.com/problems/two-sum
> Baidu, Airbnb, Netease, Cisco, Amazon, Aetion, Box, Mathworks, Zoom, Google, Cloudera, Intel, Indeed, Godaddy, Walmart Global Tech, Salesforce, Didi, Affirm, Vmware, Yandex, Microsoft, Adobe, Alibaba, Jpmorgan, Linkedin, Citadel, Emc, Groupon, Intuit, Twitter, Nvidia, Twilio, Valve, Expedia, Yahoo, Zoho, Bookingcom, Wish, Zillow, Morgan-stanley, Drawbridge, Paypal, Huawei, Dropbox, Radius, Zomato, Roblox, Accenture, Goldman-sachs, Lyft, Yelp, Splunk, Bloomberg, Samsung, Bytedance, Servicenow, Quora, Goldman Sachs, Blackrock, Ebay, Ge-digital, Oracle, Qualcomm, Tencent, Uber, Tableau, Spotify, Morgan Stanley, American Express, Sap, Ibm, Deutsche-bank, Snapchat, Dell, Apple, Visa, Works-applications, Facebook, Factset, Audible, Expedia, Affirm, Docusign, Yahoo, Cisco, Servicenow, Goldman Sachs, Amazon, Microsoft, Oracle, Morgan-stanley, Uber, Spotify, Zulily, Google, Paypal, Snapchat, Apple, Goldman-sachs, Yelp, Facebook, Bloomberg

---

**Ques**

Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.

You may assume that every input has exactly one pair of indices i and j that satisfy the condition.

Return the answer with the smaller index first.

Example 1:
```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
Explanation: nums[0] + nums[1] == 7, so we return [0, 1].
```
Example 2:
```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```
Example 3:
```
Input: nums = [5,5], target = 10

Output: [0,1]
```
Constraints:
```
2 <= nums.length <= 1000
-10,000,000 <= nums[i] <= 10,000,000
-10,000,000 <= target <= 10,000,000
```

Recommended Time & Space Complexity
You should aim for a solution with O(n) time and O(n) space, where n is the size of the input array.


Hint 1
A brute force solution would be to check every pair of numbers in the array. This would be an O(n^2) solution. Can you think of a better way? Maybe in terms of mathematical equation?


Hint 2
Given, We need to find indices i and j such that i != j and nums[i] + nums[j] == target. Can you rearrange the equation and try to fix any index to iterate on?


Hint 3
we can iterate through nums with index i. Let difference = target - nums[i] and check if difference exists in the hash map as we iterate through the array, else store the current element in the hashmap with its index and continue. We use a hashmap for O(1) lookups.

---

**Solutions**
- so basically, 
  - given
    - Array
    - target
  - to find
    - index i &index j of array
    - && arr[i]+arr[j]=target
    - && i != j
    - Return the answer with the smaller index first.
    - You may assume that every input has exactly one pair of indices i and j that satisfy the condition.
- Solution 1 -- brute force
  - loop 1 : i 0 to n-1
    - loop 2 : j i+1 to n-1
      - if arr[i]+arr[j]=target
        - return {i,j}
  - if not found ,return {}
```cpp
// Solution 1
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for ( int i=0; i<nums.size(); i++){
            for ( int j=i+1; j<nums.size(); j++){
                if (nums[i]+nums[j] == target) { return {i,j} ; }
            }
        }
        return {};
    }
};
// Time & Space Complexity
// Time complexity: 
// O(n**2)
// Space complexity: 
// O(1)
```
- thought: let's just make checks of `(nums[i]+nums[nums.size()-i-1] == target`
  - NO, as ans can be `[0,1]`
- thought: arr[i]+arr[j]=target
  - arr[j]=target-arr[i]
  - we know target, if we just do hardwork to know arr[i] then, arr[j] will automatically come
  - YES, but then we can see arr[j] but need to extract index j 
- thought: change the data stucture
  - hashset: NO, `( hashbrown.find(nums[i] )` only returns ptr, not index, tip
  - hashmap: YES, with < value, index > 
  - pairs: YES, with < value, index > 
  - YES 
- Solution 2
  - Hash Map (Two Pass)
  - here we are finding i then j
    - { i,hash_map[target-nums[i]] }
  - make hashmap 
    - where hashmap[value]=index
  - now loop traverse, first add all array elements with index nos. in hashmap
  - then another loop, to check
    - if element's Right Side Complement exists
      - i.e. target - arr[i] exists
      - , i.e. arr[j] && target - arr[i] != arr[i] ( i.e. not point back to same element )
      - we are checking if the element 1's complement to sum the target exists to the RIGHT SIDE
      - i.e. element + Right Side Complement = target 
    - if YES, then return the i ,then j as {i,j}
  - if nothing found, it didn't exist, return empty {}
```cpp
// Solution 2
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> momos;
        for ( int i = 0; i<nums.size(); i++ ) { momos[nums[i]]=i; }     
        for ( int i = 0; i<nums.size(); i++ )
        {
            if ( momos.find(target-nums[i]) != momos.end() // or momos.count(target-nums[i])
            && momos[target-nums[i]]!= i // to avoid the case of j = i
            )
            {
                return  { i,momos[target-nums[i]]}; 
            }
            // or 
            // int diff = target - nums[i];
            // if (momos.count(diff) && momos[diff] != i) {
            //     return {i, momos[diff]};
            // }
        }   
        return {};
    }
};
// Time & Space Complexity
// Time complexity: 
// O(n)
// Space complexity: 
// O(n)
```
- Solution 3 -- optimal
  - Hash Map (One Pass)
  - Solution 2's Clever/Smart Way
  - One Pass
  - Free from Edge cases 
  - here we are finding j then i
    - { hash_map[target-nums[j]] , j }
  - now in one loop, 
    - first check 
      - if element's Left Side Complement Exists
        - i.e. Left Side Complement + Element = target
        - now we are finding LEFT SIDE, not right side; because this time we are checking before insertion
          - i.e. there is no right side elements of selected element
      - if exists then return i,then j as {i,j} 
      - else array element with index no. in hashmap
  - if nothing found, it didn't exist, return empty {}
  - here we already avoide the case of j = i

```cpp
// Solution 3
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> momos;
        for ( int j = 0; j<nums.size(); j++ ){
            if ( momos.find(target-nums[j]) != momos.end() )
            {
                return  {momos[target-nums[j]] ,j}; // not { j,momos[target-nums[j]]}; 
            }
            momos[nums[j]]=j; // not momos[nums[j]]++ as it dont make sense
            // or momos.insert( nums[j], j );
            // insertion should be second
            // else Let's say nums = [3, 2, 4] and target = 6
                // On the first loop (i=0, nums[0]=3), it calculates the complement: 6 - 3 = 3.     
                // Because you just added nums[0] to the map, the code finds 3 in the map and incorrectly matches the element with itself, returning {momos[3], 0} which is {0, 0}. This violates the i != j rule.
        }       
        return {};
    }
};
// Time & Space Complexity
// Time complexity: 
// O(n)
// Space complexity: 
// O(n)
```
- thought: let's just sort the array and play first and last in one loop
  - NO, as we lost the indexes of array
  - thought: if we use value_index_pairs_vector instead of vector array
      - our for loop checks pairs at symmetrical indices:
        - When i = 0, it checks the 1st smallest (pv[0]) and the 1st largest (pv[size-1]).
        - When i = 1, it checks the 2nd smallest (pv[1]) and the 2nd largest (pv[size-2]).
        - ...and so on.
      - ```cpp
        // // WRONG
        // class Solution {
        // public:
        //     vector<int> twoSum(vector<int>& nums, int target) {
        //         vector< pair<int,int> > pv;
        //         for (int i=0; i< nums.size(); i++){
        //             pv.push_back( {nums[i],i} );
        //         }
        //         sort(pv.begin(), pv.end());
        //         for (int i=0 ; i<pv.size(); i++)
        //             if (
        //                 pv[i].first
        //                 +
        //                 pv[pv.size()-i-1].first
        //                 ==
        //                 target
        //             )
        //             {
        //                 return (
        //                     {
        //                         pv[i].second
        //                         ,
        //                         pv[pv.size()-1-i].second
        //                     }
        //                 );
        //             }
        //         return {};
        //     }
        // };
        ```
      - NO
          - The problem is that the correct pair isn't always symmetrical. The solution might be the 1st smallest and the 3rd largest
- Solution 4
  - Sorting  
  - This is the two-pointer technique. I just need to put this logic into a while (left < right) loop. It's guaranteed to find the solution.
  - thought: if we use value_index_pairs_vector instead of vector array. Let's go back to the sorted list and think again. I have one pointer at the start (left) and one at the end (right).
    - The Core Question: I have sum = left_value + right_value. How does this sum guide my next move?
    - Case 1: sum > target: The total is too big. To make it smaller, the only logical move is to decrease the larger number. So, I must move the right pointer inward (right--).
    - Case 2: sum < target: The total is too small. To make it bigger, the only logical move is to increase the smaller number. So, I must move the left pointer inward (left++).
    - YES
    - textbook-quality solution !!!
```cpp
// Solution 4
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector< pair<int,int> > pv;
        for (int i=0; i< nums.size(); i++){
            pv.push_back( {nums[i],i} );
        }
        sort(pv.begin(), pv.end());
        int i =0;
        int j = nums.size() -1;
        while (i<j){
            if ( pv[i].first + pv[j].first == target )
            {
                return  { min(pv[i].second , pv[j].second) , max(pv[i].second , pv[j].second) } ;
                // NOT return ( { min(pv[i].second , pv[j].second) , max(pv[i].second , pv[j].second) } );
                // The syntax ( { ... } ) is not the standard way to return a newly created vector. The compiler misinterprets it and complains that it can't convert the result to a std::vector<int>
            } 
            else if ( pv[i].first + pv[j].first < target ) { i++; }
            else if ( pv[i].first + pv[j].first > target ) { j--; }

        }
        
        return {};
    }
};
// Time & Space Complexity
// Time complexity: 
// O(nlogn)
// Space complexity: 
// O(n)
```

---
### 5 Group Anagrams [Medium]

- https://leetcode.com/problems/group-anagrams/
> Twilio, Salesforce, Affirm, Docusign, Yahoo, Cisco, Servicenow, Blackrock, Goldman Sachs, Ebay, Vmware, Tiktok, Bookingcom, Electronic-arts, Amazon, Wish, Microsoft, Yandex, Oracle, Qualtrics, Bloomberg, Adobe, Alation, Uber, Nutanix, Jpmorgan, Tesla, Mathworks, Zulily, Google, Hulu, Ibm, Snapchat, Apple, Intuit, Visa, Goldman-sachs, Yelp, Facebook, Walmart Global Tech

---

**Ques**

Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.
 

Example 1:
```
Input: strs = ["eat","tea","tan","ate","nat","bat"]

Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```
Explanation:
```
There is no string in strs that can be rearranged to form "bat".
The strings "nat" and "tan" are anagrams as they can be rearranged to form each other.
The strings "ate", "eat", and "tea" are anagrams as they can be rearranged to form each other.
```
Example 2:
```
Input: strs = ["x"]

Output: [["x"]]
```
Example 3:
```
Input: strs = ["a"]

Output: [["a"]]
```
 

Constraints:
```
1 <= strs.length <= 1000
0 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.
```

Recommended Time & Space Complexity
You should aim for a solution with O(m * n) time and O(m) space, where m is the number of strings and n is the length of the longest string.


Hint 1
A naive solution would be to sort each string and group them using a hash map. This would be an O(m * nlogn) solution. Though this solution is acceptable, can you think of a better way without sorting the strings?


Hint 2
By the definition of an anagram, we only care about the frequency of each character in a string. How is this helpful in solving the problem?


Hint 3
We can simply use an array of size O(26), since the character set is a through z (26 continuous characters), to count the frequency of each character in a string. Then, we can use this array as the key in the hash map to group the strings.

---

**Solutions**
- basically  
  - given array of strs
  - return array of sublists of anagram string groups
- thought: You're trying to use a std::vector like a dictionary or a hash map, where you can look up a value using a string key. 
  - NO
  - However, a std::vector in C++ doesn't work that way; it's just a dynamic array that you can access with integer indices (like tempo[0], tempo[1], etc.). It doesn't have a .find() method that takes a string, nor can you use a string inside the square brackets [].
- thought: The perfect tool for this is a std::unordered_map. It allows you to store key-value pairs, which is exactly what you need: the sorted string as the key and the list of anagrams as the value.
  - YES
- Solution 1 -- brute force
  - Sorting
  - thought: 
    - i grouped them based on id as identity of sorted string
    - so i need to do one sort operation each traversal to find id which is sorted str
    - YES
  - make unord hashmap tempo
    - contain stuff as pairs {"abc", {"acb", "bac"}}
      - "abc"
      - {"acb", "bac"}
  - traverse through array of strs
    - each element
    - sort it using sort stl
    - if sorted string exists in tempo
      - append the element in sorted pair 
    - else
      - make pair of 
        - sorted element key
        - empty array
  - make new vector of vector of string fin
  - traverse through tempo 
    - append second of pair into fin
  - return fin
  - TC
    - for each str : n log n from sort
    - for arra of m elements : m* n log n
```cpp
// Solution 1
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map< string, vector<string> > tempo;

        for ( int i=0 ; i<strs.size() ; i++){
            // one string iteration "string1" strs[i]
            string s = strs[i]; 
            sort(s.begin(),s.end()); // s is sorted strs[i]
            
            // Add the original string to the vector associated with the sorted key.
            // If the key doesn't exist, C++ creates it automatically!
            tempo[s].push_back(strs[i]);
        //     if ( tempo.find(s) != tempo.end ) // if s exist in tempo
        //     {
        //         // append strs[i] in tempo[s] tempo[s].push_back(strs[i])
        //         tempo[s].push_back(strs[i]);
        //     }
        //     else 
        //     {
        //         // make new str,{} in tempo
        //         tempo[s].push_back(strs[i]);
        //     }
        }
        vector<vector<string>> fin;
        for ( auto const& pairs: tempo){ // eg: pair { "abc", {array of anagrams} } 
            fin.push_back(pairs.second);
        }
        return fin;
    }
};
// Time & Space Complexity
// Time complexity: 
// O(m‚àónlogn)
// Space complexity: 
// O(m‚àón)
// Where 
// m is the number of strings and 
// n is the length of the longest string.
```
- Solution 2 -- optimal
  - Hash Map/Table
  - same working of Solution 1 
  - but another ID
  - thought: 
    - i grouped them based on id as identity
    - so i did earlier to do one sort operation each traversal to find id which is sorted str
    - is there any other way to make ids and group play??
    - idea: make an id
    - made of 0s and 1s of freq array of 26 alphabet & one seperator
      - eg: abc => 1.1.1.0.0.0.0..........................0
        - bca => 1.1.1.0.0.....................0
          - same as abc, cab, bac etc.
    - YES, really like adj matrix 
  - TC: 
    - just using hashmap
    - just counting stuff
    - O( m * n * 26 )
      - n is elements size
      - m is array size
      - 26 is Alphabets iteration 
```cpp
// Solution 2
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map< string, vector<string> > tempo;
        for ( const string& s : strs)
        {
            // Create a character count array for each string
            // An array of 26 integers, one for each letter 'a' through 'z'.
            vector<int> freq(26,0);
            for (char c: s)
            {
                freq[c-'a']++;
            }
            // Build a unique key string from the count array.
            // For "eat": count['a'-'a']=1, count['e'-'a']=1, count['t'-'a']=1
            // Key might look like: "1.0.0.0.1.....1...."
            string _ID = "";
            for ( int i =0; i<26; i++)
            {
                _ID+= to_string(freq[i]);
                _ID+="."; // as a seperator
            }
            tempo[_ID].push_back(s);
        }
        vector< vector<string>> fin={};
        for (auto const& [key,val]: tempo)
        {
            fin.push_back(val);
        }
        return fin;
    }
};
// Time & Space Complexity
// Time complexity: 
// O(m‚àón)
// Space complexity:
// O(m) extra space.
// O(m‚àón) space for the output list.
// Where 
// m is the number of strings and 
// n is the length of the longest string.
```

---
### 6 Top K Frequent Elements [Medium]

- https://leetcode.com/problems/top-k-frequent-elements/description/
> Bytedance, Yahoo, Cisco, Vmware, Ebay, Pocket-gems, Amazon, Microsoft, Oracle, Adobe, Uber, Spotify, Google, Linkedin, Hulu, Snapchat, Apple, Goldman-sachs, Yelp, Facebook, Bloomberg

---

**Ques**

Given an integer array nums and an integer k, return the k most frequent elements within the array.

The test cases are generated such that the answer is always unique.

You may return the output in any order.

Example 1:
```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```
Example 2:
```
Input: nums = [7,7], k = 1

Output: [7]
```
Constraints:
```
1 <= nums.length <= 10^4.
-1000 <= nums[i] <= 1000
1 <= k <= number of distinct elements in nums.
```
Recommended Time & Space Complexity
You should aim for a solution with O(n) time and O(n) space, where n is the size of the input array.

Hint 1
A naive solution would be to count the frequency of each number and then sort the array based on each element‚Äôs frequency. After that, we would select the top k frequent elements. This would be an O(nlogn) solution. Though this solution is acceptable, can you think of a better way?

Hint 2
Can you think of an algorithm which involves grouping numbers based on their frequency?

Hint 3
Use the bucket sort algorithm to create n buckets, grouping numbers based on their frequencies from 1 to n. Then, pick the top k numbers from the buckets, starting from n down to 1.

---

**Solutions**
- this question seems to be easy
- but this is quite hard to solve once
- basically
  - Given an integer array nums and an integer k
  - return the k most frequent elements within the array.
  - The test cases are generated such that the answer is always unique.
- thought : 
  - was blackout, full algo didn't came at first try
  - origin thinking was to make a map containing freq, element 
  - sort them desc
  - make fin arr
  - and while k--
    - append fin freq's element
  - return
  - NO
    - was beginner, other way too as iteration 
  - Solution 1 came out of incapability of using just unordered_map or vector or vector pair
    - i tried here to use their synergy
    - YES
  - Will try this thought inspiration in Sol 2
    - YES

- Solution 1 --  optimal
  - Bucket Sort
  - Need to Revisit after Getting Grip
  - thought: the "bucket" array, where the index represents the frequency (count) Advantage
    ```
    eg:
    [1,1,2,2,2,3,10]
    - this is unbounded
      - i.e. maxelement of this array exceed size of array
      - i.e. any element 100000,99999,etc. can be in this array
      - COUNT IS BTW TIMES OF OCCURENCE
    - way 1 to store
      - i :       [0,1,2,3,4,5,6,7,8,9,10] IDX  
      - count :   [0,2,3,1,0,0,0,0,0,0,1] VALUES 
    - way 2 to store -- optimal
      - count : [0,1,2,3,4,5,6] IDX 
      - i : [[null],[10,3],[1],[2],X,X,X] VALUES
      - very much TC & SC Efficient
      - + new way to process
        - also even if array is big, still stop way 2 bucket till k , ignore after that
          - starting from reverse obv.
          - i.e. if k=2, so 
            - 6,5,4 is out ,no data
            - process 3,2
            - ignore rest !!!
        - linear time
    ```
  - The two-step process is the standard, efficient pattern.
  - Use a map for what it's best at: fast lookups and counting.
  - Use a vector for what it's best at: storing data in a sequence that can be sorted.
  - make map named tempo
    - {{number,freq},{number,freq},{number,freq}}
    - Count the frequency of each number.
  - make bucket vector tempo2
    - {{number,number,number},{number,number,number},{number,number,number}}
  - here 0 index vector have 0 freq nos, 1 index nos have 1 freq nos, etc
  - 0 would be {} obv
    - useage
  - eg: buckets[5] = a list of all numbers that appeared exactly 5 times.
  - eg: buckets[4] = a list of all numbers that appeared exactly 4 times.
  - now traverse tempo
    - store tempo2[freq].push_back(number)
  - done
  - now to just append to fin array and return fin
  - actual_size_bucket = tempo2.size() -1
  - travers tempo2 reverse order
    - You can't sort the buckets vector itself, because the frequency information is stored in its indices, not in the values it holds. Sorting it would scramble this crucial relationship.
    - so now
    - traverse i lastFreq -> 0 && fin<=k
  - for nums in tempo[i]
    - fin.push_back(nums)
  - check if fin==k
    - The test cases are generated such that the answer is always unique
    - break
  - else
    - continue
  - return fin
```cpp
// Solution 1
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> tempo; // COUNT
        // 1 Count the frequency of each number.
        for ( const int i : nums )
        {
            tempo[i]++;
        }

        // The two-step process is the standard, efficient pattern.
        // Use a map for what it's best at: fast lookups and counting.
        // Use a vector for what it's best at: storing data in a sequence that can be sorted.
        
        // 2 Create buckets. The index is the frequency.
        // The size is nums.size() + 1 because a number can appear at most nums.size() times.
        vector<vector<int>> tempo2(nums.size() + 1); // FREQ
        // Connecting Frequency to Array Indexing To store the number 5 in our buckets vector, we need to place it at the index corresponding to its frequency. So, we need to access buckets[4].
        // Because C++ vectors are 0-indexed, to have a valid index at 4, the vector must have a size of at least 5 (to contain indices 0, 1, 2, 3, and 4).
        // Therefore, if the maximum possible frequency is nums.size(), the required size for the buckets vector is nums.size() + 1.
        for ( const auto& [key,value] : tempo) // key,value are num, freq res.
        {
            tempo2[value].push_back(key);
        }

        // NO sort(tempo2.rbegin(),tempo2.rend());
        // You can't sort the buckets vector itself, because the frequency information is stored in its indices, not in the values it holds. Sorting it would scramble this crucial relationship.
        // You can't sort the buckets vector itself, because the frequency information is stored in its indices, not in the values it holds. Sorting it would scramble this crucial relationship.
        // The Role of the buckets Vector
        //     Think of the buckets vector like a series of filing cabinet drawers. The number on each drawer is the frequency (the index), and inside the drawer are the numbers that appeared that many times.
        //     eg: buckets[5] = a list of all numbers that appeared exactly 5 times.
        //     eg: buckets[4] = a list of all numbers that appeared exactly 4 times.
        vector<int> fin; 
        // 3 Iterate backwards from the highest possible frequency.
        // Add elements to the result until we have k elements.
        int actual_size_bucket = tempo2.size() -1;
        for ( int i = actual_size_bucket ; i >=0 && fin.size()<k ; --i )
        {
            for ( int num: tempo2[i]){
                fin.push_back(num);
                if ( fin.size() == k){
                    break;
                }
            }
        }
        return fin;
        
        
    }
};
// Time & Space Complexity
// Time complexity: 
// O(n)
// Space complexity: 
// O(n)

```
- Solution 2 -- brute force
- Sorting
  - Count frequencies
    - make unord map <int,int> freqMap
    - for nums in nums
      - freqMap num ++
        - it will inc freq of existing fre in freq map
        - or if new so make new freq
  - Convert to a vector of pairs { freq, number}
    - make vect of pairs freqVec 
    - traverse map_pair in freqMap
      - freqVec.push_back( { map_pair.second, map_pair.first })
  - Sort the vector by frequency in descending order
    - use sort(freqVec.rbegin(), freqVec.rend())
  - Extract the top k elements
    - make fin which is vect int array
    - i 0->k-1 
      - fin.push_back freqVec [i] Second
  - return fin
```cpp
// Solution 2
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> freqMap;
        for ( const int i : nums )
        {
            freqMap[i]++;
        }
        vector<pair<int,int>> freqVect;
        for ( const auto& [k,v]: freqMap){
            freqVect.push_back({v,k});
        }
        sort(freqVect.rbegin(),freqVect.rend());
        vector<int> fin; 
        int idx=0;
        while(k--)
        {
            fin.push_back(freqVect[idx].second);
            idx++;
        }
        return fin;
    }
};
// Time & Space Complexity
// Time complexity: 
// O(nlogn)
// Space complexity: 
// O(n)
```
- Solution 3
  - Min-Heap
  - Need to Revisit After Getting grip on Heap
  - We don't really need to sort whole arr
  - We just need to find k freq. so extract k times too..
  - heap push O(n)
  - pop only k times O(klogn)
    - each pop O(logn)
```cpp
// Solution 3
// Defines the 'Solution' class, which holds our function
class Solution {public: 
// Declares the function 'topKFrequent' which takes a vector of integers 'nums'
// and an integer 'k', and returns a vector of integers.
     vector<int> topKFrequent(vector<int>& nums, int k) {
// 1. --- Frequency Counting ---

// Create an unordered_map (hash map) to store the frequency of each number.
// The 'key' will be the number from 'nums', and the 'value' will be its count.
    unordered_map<int,int> count;
// Loop through each number ('num') in the input vector 'nums'.
// Increment the count for the current 'num' in the map.
// If 'num' is not in the map yet, it's automatically added with a count of 1.
    for (int num: nums) {count[num]++;}

// 2. --- Min-Heap for Top K ---

// Create a min-heap (priority_queue). This is the clever part!
// It stores pairs: {frequency, number}.
// 'greater<...>' makes it a min-heap, meaning the pair with the *smallest* // frequency will always be at the top.
    priority_queue<pair<int,int> , vector<pair<int,int>> ,greater<pair<int,int>>> hp; // heap
// Loop through each 'entry' (a {number, frequency} pair) in our 'count' map.
// Note: 'entry.first' is the number, 'entry.second' is its frequency.
    for ( auto& i : count){

// Push the {frequency, number} pair onto the min-heap.
// We put frequency *first* so the heap sorts by frequency.
        hp.push( {i.second,i.first} ) ;


// This is the key optimization:
// If the heap's size exceeds 'k', we remove the smallest element.
// Since it's a min-heap, 'heap.pop()' removes the element with the 
// *lowest frequency* currently in the heap.
        if ( hp.size() > k) {hp.pop();}
    }   


// After the loop, the heap contains exactly the 'k' elements 
// with the highest frequencies.

// 3. --- Final Result ---

// Create a vector 'res' to store our final result.
    vector<int> fin; 

// Loop 'k' times to extract all elements from the heap.
// (Alternatively, you could use 'while (!heap.empty())')
    for( int i = 0; i<k ; i++){

// Get the top element from the heap (which is a {frequency, number} pair).
// 'heap.top().second' accesses the 'number' part of the pair.
        fin.push_back(hp.top().second); 
        // NO fin.push_back(hp.top().second());
        // NO fin.push_back(hp.top.second());
        // NO fin.push_back(hp.top.second);

// Remove the top element from the heap to access the next one.
        hp.pop();
    }

// Return the 'res' vector containing the top k frequent numbers.
// Note: The order in 'res' isn't guaranteed (e.g., it might be 
// from k-th most frequent to 1st most frequent), but the problem 
// usually allows any order.
    return fin;
    }
};
// Time & Space Complexity
// Time complexity: 
// O(nlogk)
// Space complexity: 
// O(n+k)
// Where 
// n is the length of the array and 
// k is the number of top frequent elements.

```
---




---
# DSA_MASTERY
# Chapter 3:  Variables and Constants

## I. Introduction and Series Context

This content is part of the C++ series titled **"Chai aur Code,"** which is also referred to as **"Chai aur C++"**. The series is widely followed, noted by the phrase "pura India yahin se padh raha hai" (the whole of India is reading/learning from here nowadays).

### Video Goals and Pacing

The video is intentionally kept at a **slow pace** so that the audience can enjoy the content. The video covers a limited number of topics because it focuses on the starting phase of programming.

**Note on Starting Programming:** In the beginning phase of programming, anxiety and lack of understanding are common feelings. The goal is to understand the basics, C++, and perform some practice.

## II. Setting Up the Code Structure

### File and Folder Naming

We start with a fresh video and a fresh start, even if some initial work was covered previously.

1.  **Folder Structure:** The folder structure starts with `01` for easy organization.
2.  **Best Practices:** All files and structures are created using best practices.
3.  **Folder Name:** The folder is named `01_var_const` because the focus is on **variables and constants**.
4.  **File Name:** The file created inside the folder is typically named **`main.cpp`**.

### Why `main.cpp`?

Using `main.cpp` is a very common syntax. When you create `hello.cpp`, it usually includes a main method.

In large software development, a single folder might contain many supporting files (`.h` files and `.cpp` files). Since the end goal is to create one executable software, `main.cpp` is often the name given to the primary execution file, especially when it is the only executable file or when it is unclear which file among thousands should be run.

## III. Basic C++ Program Structure

The following code is written as an exercise and revision.

| Component | Description/Function | Revision Questions (Asked in Source) |
| :--- | :--- | :--- |
| `#include` | Used to include libraries. | What is `#include`? |
| `iostream` | Input/Output stream. | What is `iostream`? |
| `using namespace std;` | Refers to a container (like the box example previously discussed). **Semicolon** is very necessary here. | |
| `int main()` | The basic method structure. | |
| `cout` | Responsible for logging any given string or value to the console (standard output). | |
| `endl` | Stands for **End of Line**. It ends the current line. Note: This is one of several mechanisms available to end a line. | |
| `return 0;` | A sign of a good program. It is required because the method declared that it will return an **integer** (`int main`). **Semicolon** must not be forgotten. | |

### Code Block: Basic C++ Program

```cpp
#include <iostream>
using namespace std;

int main() {
    // Basic output structure
    cout << "Welcome to Chai with CPP" << endl;
    
    // Good practice
    return 0; 
}
```

## IV. Understanding and Using Comments

Comments are often seen inside programs.

### Purpose of Comments

The primary use of comments is when you have many lines of code or many methods and you need to determine which part is causing a problem. You use comments to temporarily remove (hide) certain code lines and test the program.

### Compiler Interaction with Comments

The compilation process involves the **Code File** (a basic text file) going through a **Compiler** (the C++ compiler) to produce an **Executable**.

1.  During compilation, the compiler extracts and gathers all keywords (like `int`, `main`, `namespace`) to build an Abstract Syntax Tree (AST).
2.  When a line is commented out, the **compiler ignores that line totally**.

### Types of Comments and Shortcuts

| Type | Syntax/Method | Usage |
| :--- | :--- | :--- |
| **Single Line Comment** | Press **Control** + **Slash (/)**. | This is an almost **universal shortcut** in VS Code, regardless of the programming language (C++, Java, JavaScript). It is used to toggle commenting on and off. This is the professional developer preference. |
| **Multi-Line Comment** | Start with `/*` and end with `*/`. | This method exists but is often favored by academic standards. |

### Professional Commenting Best Practices

While academics often suggest writing a comment before every line or method:

*   **Avoid comments that add no value** (e.g., "This line prints a welcome message"), as the code itself is clear.
*   It is considered a **bad practice** in real-world software development to write unnecessary comments.
*   **Comments should only be written where complexity has been introduced**.

### White Spaces

Extra white spaces (e.g., excessive line breaks or tabs) do not affect the compiler. The compiler has **no concern** with white spaces.

### VS Code Line Manipulation

A useful shortcut for moving code lines is pressing **Option** (or **Alt**) and the **Down Arrow** key. This is easier and faster than cutting and pasting code.

## V. The Fundamental Role of Data

The main reason for creating any program or software is **data**. Data-related operations generally fall into three categories:

1.  **Store:** Storing data.
2.  **Process:** Manipulating data.
3.  **Display/Read:** Showing the result to the user (the ultimate goal of data).

> Data is typically displayed only **after** it has been stored or processed.

### Data Storage

Storage is necessary because data needs to be maintained (e.g., maintaining a user's score or username in a game or a bank balance). Data can be stored in memory (RAM), a disk, or a database.

*   **Concepts related to Storage:** Variables, Constants, Data Types (Integers, Strings, Booleans/True-False), Data Structures (Arrays, Objects, Link Lists, Custom structures).

### Data Processing

Processing involves taking stored data and acting upon it.

*   **Example:** Checking if a stored username contains only numbers and characters, or if it contains unauthorized special characters.
*   **Concepts related to Processing:** Conditional statements (`if-else`), Loops, `switch` cases, and Object-Oriented Programming (OOP).

## VI. Variable and Constant Declaration

We need to store data using variables, rather than just repeatedly using `cout`.

### Variables

Variables are like a box or a chair that can be **opened and changed**. Data inside a variable can be modified.

#### 1. Declaration (The Syntax)

When you declare a variable, you are asking the RAM (Random Access Memory) for a small box and giving that box a name (an identifier).

```cpp
int score;
```

*   **`int`**: Specifies the data type (in this case, an Integer) that will be stored.
*   **`score`**: The name given to the memory location (the box).
*   **Vocabulary:** This specific step (`int score;`) is called **Variable Declaration**.

#### 2. Initialization (Assigning Value)

Initialization means assigning a value to the declared variable.

**Two-Step Process:**

1.  Declaration:
    ```cpp
    int score; // Declared, but value unknown/unassigned
    ```
2.  Initialization/Usage:
    ```cpp
    score = 110; // Value assigned later
    ```

**Combined Declaration and Initialization (Single Step):**

If the value is known from the beginning, you can combine these steps.

```cpp
int balance = 500;
```

**Why Use Two Steps?**

Sometimes, you need to reference the memory location first, and then add the value after some processing occurs or data is read from a database. Programming always provides options.

#### 3. Modification

Once a variable is declared, you use it directly without re-declaring it. Changing the value is allowed:

```cpp
int hiteshBalance = 500;
hiteshBalance = 1000; // Change is complete and totally allowed
```

### Identifiers (Variable Naming Rules)

The names given to variables are called **Identifiers**.

#### Keywords

You cannot use the language's reserved **keywords** (special words like `int` or `for`) as variable names. The compiler will give errors.

#### Allowed Naming Conventions

Variable names should be **meaningful**. Various styles are allowed and common:

1.  **Camel Case:** `hiteshBalance` (using capitalization).
2.  **Snake Case:** `hitesh_balance` (using underscores).
    *   Underscores are sometimes used to imply that a variable holds a special meaning or should not be exposed externally.
3.  **Generalized:** `balance`.
4.  **Numbers at the End:** Names like `hiteshBalance1` or `hiteshBalance2` are allowed, although the speaker generally prefers meaningful names without trailing numbers.

#### What is NOT Allowed

1.  **Spaces:** Spaces are **not allowed** (e.g., `hitesh balance`) because the compiler treats them as separate variables.
2.  **Starting with an Integer:** Names that start with a number or are structured confusingly (e.g., if `one` is used in place of a variable name).

### Constants

Constants use a special keyword to ensure the data stored **cannot be changed**. This is useful for values that must remain fixed throughout the program (e.g., a unique customer ID).

#### 1. Declaration using `const`

The `const` keyword is used before the data type:

```cpp
const int uniqueID = 232323; // This uniqueID is now constant
```

#### 2. Attempting to Modify a Constant

If you try to change the value of a constant, the compiler generates an error.

```cpp
// Attempting to change uniqueID
uniqueID = 121212; 
```

**Error Message:** The attempt will result in an error stating that the `expression must be a modifiable lvalue`.

*   **L-Value:** Left-Hand Side value.
*   **R-Value:** Right-Hand Side value.

The compiler indicates that the Left-Hand Side value (`uniqueID`) cannot be changed because it was declared with `const`.

## Left-Hand Side value üì¨ & Right-Hand Side value ‚úâÔ∏è
### L-value (The Mailbox) üì¨

An **L-value** refers to a **memory location** that has an address. Because it's a location, you can go back to it later to store new things or see what's there. It's the mailbox itself.

  * **Key Property:** It has a persistent address. It's a **container**.
  * **What you can do:** You can put something **into** it (assign a value to it) and you can also see **what's inside** it (read its value).
  * **Mnemonic:** Think **L** for **L**ocation.

In code, a variable is a perfect example of an L-value.

```cpp
int score = 95;
// 'score' is an L-value. It refers to a specific spot in memory
// where the number 95 is stored.

score = 100; // This is VALID because you can put a new value into the 'score' location.
```

-----

### R-value (The Letter) ‚úâÔ∏è

An **R-value** is a **temporary value** that doesn't have a persistent memory location. It's the letter you are about to put *in* the mailbox. Once it's delivered (or the expression is evaluated), the letter itself is gone; only its value was used.

  * **Key Property:** It does not have a persistent address. It's the **content**.
  * **What you can do:** You can only **read** its value. You can't assign a new value *to* it.
  * **Mnemonic:** Think **R** for **R**ead or **R**ight-hand side.

Literal numbers or the result of a calculation are common R-values.

```cpp
int score = 95;
// '95' is an R-value. It's a pure value.

int finalScore = score + 5;
// 'score + 5' is an R-value. The computer calculates 100,
// and this temporary result of 100 is the R-value.
```

-----

#### The Golden Rule: Assignment

The names "Left-Hand Side" and "Right-Hand Side" come from the assignment operator (`=`).

> **An L-value can be on the left or right side of `=`, but an R-value can ONLY be on the right side.**

Let's see why:

```cpp
int x; // x is an L-value (a memory location/mailbox)

x = 10;   // Correct!
          // L-value = R-value
          // (Put the letter '10' into the mailbox 'x')

10 = x;   // ERROR!
          // R-value = L-value
          // (This is like trying to assign the mailbox to the letter. It makes no sense!)
```

#### Why This Mattered in Your Last Example

You saw the error `expression must be a modifiable lvalue`. Let's break that down with what we know now:

```cpp
const int UNIQUE_ID = 12345;
UNIQUE_ID = 54321; // ERROR!
```

  * `UNIQUE_ID` is an **L-value** because it has a memory location.
  * However, because you marked it `const`, the compiler made it a **non-modifiable L-value**.
  * The error is telling you: "The thing on the left-hand side (`UNIQUE_ID`) is a location, but I am not allowed to modify it\!"

| Feature | L-value (Location) | R-value (Value) |
| :--- | :--- | :--- |
| **Analogy** | Mailbox üì¨ | Letter ‚úâÔ∏è |
| **Has Address?** | **Yes**, a persistent memory location. | **No**, it's temporary. |
| **Can be on LHS of `=`?** | **Yes** (if not `const`). | **Never**. |
| **Can be on RHS of `=`?** | **Yes**. | **Yes**. |
| **Example** | `int x;` (`x` is the L-value) | `100`, `(x + 5)` |

## VII. Next Steps in Programming

The next step is to master data storage concepts by understanding other available data types:

*   How to store **String** data.
*   How to store **Boolean** (True/False) values.

Once data storage is fully understood, the focus shifts to **data processing** (how data can be processed in different ways). The full path involves understanding storage, then processing, and then building logic and programs.

Of course\! Let's break down L-values and R-values with a simple analogy. This concept is fundamental to understanding how C++ handles data and memory.

Think of your computer's memory as a street lined with mailboxes.

## Code
```cpp
#include<bits/stdc++.h>
// main.cpp is a very common syntax.In large software development,main.cpp is often the name given to the primary execution file
using namespace std;
int main(){
    // Comments
    // The compilation process involves the Code File (a basic text file) going through a Compiler (the C++ compiler) to produce an Executable.
    // 1. During compilation, the compiler extracts and gathers all keywords (like int, main, namespace) to build an Abstract Syntax Tree (AST).
    // 2. When a line is commented out, the compiler ignores that line totally.

    // ctrl + / VSC Shortcut
    /*
    Multiline comment
    */

    // Avoid comments that add no value, It is considered a bad practice in real-world software development to write unnecessary comments.
    // Comments should only be written where complexity has been introduced.


    // Data
    // Store: Storing data. DS
    // Process: Manipulating data. A
    // Display/Read: Showing the result to the user (the ultimate goal of data).

    // Variables
    // When you declare a variable, you are asking the RAM (Random Access Memory) for a small box and giving that box a name (an identifier)
    // Declaration 
    int score                      ;     // Extra white spaces (e.g., excessive line breaks or tabs) do not affect the compiler. The compiler has no concern with white spaces
    // Initialization/Usage
    score = 100;
    // Combined Declaration and Initialization 
    int balance =1;
    // Modification
    balance = 999999;  // Change is complete and totally allowed

    // Identifiers (Variable Naming Rules)
    // NO Keywords
    // YES baliKing // camelCase
    // YES bali_king // snake_case
    // NO 1bali // no start with int
    // NO bali king // no spaces
    // YES _baliKey // typical norm to show sensitive info

    // Contants
    // if you mark any variable const, the compiler made it a non-modifiable L-value.
    // If you try to change the value of a constant, the compiler generates an error.
    const int rollno1 = 122;
    // rollno1 = 0; // NO, ERROR
    // // error: assignment of read-only variable ‚Äòrollno1‚Äô

    // Left-Hand Side value 
    // where variable is at left
    // persistent
    int x = 10; // LHS => x
    // Right-Hand Side value
    // var also at right
    // inpersistent
    int y = x*x ; // RHS => x*x
    
    // NO int y = (x**2); 
    // C++ does not use ** for exponentiation (calculating powers).
    // use std::pow(number, 2)

    return 0;
}
```
---
# FULLSTACK_WEBDEV
## Chapter 3.12.: Emmet, headings and block vs inline

> HTML is all about Markup, not just link external resources, but internal resources too !!!

### I. Introduction and Lecture Structure

The video lectures will increase in length from now onwards. This is because creating videos that are only two, three, or five minutes long means the moment the video starts, it just ends up.

The goal is to have a **more formalized lecture** so that the student feels connectivity, stays in the comfort zone, and code can be written together. The teaching style is designed to be "very comforty". The interaction is intended to feel like a one-to-one conversation.

Since lectures will be longer, students can always **bookmark the timing** where they feel it is important or if they want to continue later (maybe after 1 hour or another day).

This lecture will involve writing more code and discussing documentation, including the flaws of the documentation, and what is wrong with them.

### II. Approach to Learning HTML and Documentation

#### A. Core Philosophy of Learning

A critical note to remember is that **you do not need to learn everything in HTML**. In fact, nobody knows everything in HTML.

Learning occurs on the go, based on the requirements at that point of time, and by knowing some good practices. The magic of programming is not knowing everything, but knowing **how to find that information** and **where to look for it**. This is the exact goal for moving forward in HTML.

The lecture will be a little longer.

#### B. Analyzing HTML Documentation

There are a couple of ways to find HTML documentation.

1.  **W3 Schools:** This is a very famous school. It offers everything (HTML introduction, headings, paragraphs, formatting, quotes, and colors). However, it is **overwhelming**, making it difficult to learn all these things. Some people who try to go through all the lessons still do not feel comfortable writing HTML.
2.  **MDN HTML (Mozilla Developer Network):** This is the instructor's favorite documentation, but it is "even a crazier of documentation," especially for somebody who is just getting started. It is almost impossible to read through and figure out what to read, what to avoid, and what to skip. The documentation jumps between topics (e.g., HTML tables, introduction, multimedia). The reference section provides all tags, including **deprecated ones** that no longer exist (e.g., the `big` tag).
    *   The way to learn through these documentations requires guidance and a specific style.
    *   **MDN is the better resource** compared to W3S (though W3S is also good).
    *   Initial attempts to navigate MDN guides reveal confusing terminology, such as "content categories," which include "main content categories," "form related," and "specific content," giving "zero idea what it is".
    *   Sections also include: metadata content, flow content, sectioning of the content, and heading.

It is better to jump directly into the code part and then reference the documentation in between.

### III. Writing Basic HTML Code

#### A. File Setup and Naming Convention

1.  Create a new file named `zero one`.
2.  The full name used is `intro HTML`.
3.  **Best Practice:** The better naming convention is to use underscores (`_`). Dashes (`-`) are also fine, but **no spaces**. Spaces are not a good thing in the web browser.

#### B. Generating Initial HTML Structure

The first step uses an Emmet shortcut:

1.  Type `exclamation` (`!`).
2.  Hit the `tab` key.
3.  Hit the `tab` key one more time (the cursor lands on the document title).
4.  Hold down the `option` key, delete the word `document`, and set the title, for example, `headings`.
5.  Hit the `tab` key one more time (the cursor lands inside the `body` section).

#### C. Emmet Shortcuts for Content

A standard way to create a tag is to type `html h one` and hit `tab`, which fills it up.

A quicker way to add boilerplate text:

1.  Write `h one`.
2.  Use the arrow symbol (`>`).
3.  Write `lorem` and specify the word count, e.g., `six`.
4.  Hit the `tab` key. (Note: Do not hit space then tab; it needs to be all in one flow).
5.  When suggested ("emit abbreviation"), hit `tab`.

This shortcut generates exactly six words of *lorem ipsum*, which is a boilerplate text.

### IV. HTML Headings and Paragraphs

#### A. Heading Tags (H1 to H6)

There are six levels of headings, ranging from `h1` to `h6`.

*   **Crucial Concept:** Heading levels are **not** based on size (i.e., `h1` is not necessarily bigger than `h2`). Sizing, colors, fonts, and text can be manipulated through CSS.
*   **Purpose:** Headings define **relevance and importance**.
*   The `h1` is considered the **most important heading** on your page.
*   Importance decreases with `h2`, `h3`, and so on.

**Examples using Emmet:**

```html
<h1>lorem ipsum dolor sit amet.</h1>
<h2>lorem ipsum dolor sit amet.</h2> 
<h4>lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore.</h4>
```
The first example above uses 6 words, the second uses 5 words, and the third uses 20 words.

#### B. Paragraph Tag (`p`)

A paragraph tag is used for text content.

**Example using Emmet:**

```html
<p>lorem 150 words...</p>
```
This quickly generates a document with 150 words of paragraph text.

### V. Emmet: Essential Toolkit

The shortcuts like `lorem` are part of **Emmet**.

*   Emmet used to be an externally installed plugin (e.g., in Sublime Text).
*   **VS Code provides Emmet by default**.
*   Emmet is an **essential toolkit** used by professional people to generate HTML and CSS "ridiculously fast".
*   It provides syntax abbreviation. You do not need to memorize any of it; you learn as you go.

#### A. Emmet Abbreviations Examples

| Function | Syntax | Output Description | Source |
| :--- | :--- | :--- | :--- |
| **Nesting** | `div>ul>li` | Creates a `div` containing a `ul`, which contains an `li`. | |
| **Boilerplate Text** | `lorem ten` | Generates 10 words of lorem ipsum. | |

Emmet is available for a variety of editors, including Sublime, Atom, Coda, Vim, and Webstorm.

### VI. Working with Images and Links

#### A. Image Injection (`<img>`)

Images are added using the `img` tag.

1.  **Shortcut:** Use `img` (powered by Emmet) and hit enter.
2.  **Image Tag Structure:** The image tag does **not** have an ending tag.
3.  **Source Attribute (`src`):** This is where the image source is injected.
    *   If the image is in the current directory, just use the name.
    *   If the image is inside a folder, use dot slash (`./`) to navigate.
    *   *Example:* If `HC.png` is in an `images` folder: `src="./images/HC.png"`.
4.  **Width Attribute:** Used to control the width of a large image.
    *   *Example:* `width="300 pixels"`.

**Code Example:**

```html
<img src="./images/HC.png" alt="" width="300">
```
*Note: The `alt` attribute is also part of the generated code.*

#### B. Link Injection (Anchor Tag `<a>`)

Links are created using the anchor tag (`a`).

1.  **Shortcut:** Type `a` and hit `tab`.
2.  **Anchor Tag Structure:** The `a` tag requires both a starting tag and an end tag, with content placed in between.

##### 1. Standard External/Internal Links

The link destination is provided in the **Hyper Reference (`href`) attribute**.

*   **External Website Example:** Mentioning a website.
    ```html
    <a href="HTTPs://chaicode">go to chaicode</a>
    ```
*   **Internal Document Example:** Linking to another document within the project.
    ```html
    <a href="index.html">go to index</a>
    ```
This method of linking internal documents is how websites are linked together. Relative and absolute paths are also important aspects to learn later.

##### 2. Specialized Links

The `href` attribute can be used for actions other than navigating to a website.

*   **Mail To Link:** Automatically opens the default mail client application.
    ```html
    <a href="mailto:h@h.com">Mail to</a>
    ```
*   **Telephone Link:** Automatically loads the mobile dialer and copies/pastes the number if the user is on a mobile device.
    ```html
    <a href="tel:1234567890">Call Me</a>
    ```

### VII. Core HTML Terminology

There is a specific terminology used in HTML.

| Terminology | Definition | Example Components | Source |
| :--- | :--- | :--- | :--- |
| **Element** | The whole thing, including the starting tag, the end tag, and the content in between. | `<h1 title="chaicode">Heading Text</h1>` is an element. | |
| **Tag** | What you see, specifically referring to the starting tag (`<h1 ...>`) or end tag (`</h1>`). | `<h1>` is a starting tag; `</h1>` is an end tag. | |
| **Attribute** | Properties of a tag, seen inside the starting tag. | `Src`, `alt`, `href`, `width`, `title`. | |

#### A. Universal Attribute: Title

The `title` attribute can be added to **any element** at all.

*   **Function:** It provides a tooltip.
*   **Example:**
    ```html
    <h1 title="chaicode">Heading Text</h1>
    ```
*   **Action:** When the cursor hovers over the element, a small tooltip saying "chaicode" appears. This is also known as a tooltip.

### VIII. Headings and Lists

A new file, `02_headings_and_list.html`, is created to discuss lists.

#### A. Introduction to Lists

Lists are commonly used in HTML, especially for navigation bars, footer menus, and navigation menus. Technically, HTML provides four types of lists, but the focus is on two important types: ordered lists and unordered lists.

#### B. Unordered List (`<ul>`)

*   **Shortcut:** `ul`.
*   **Structure:** Each list requires list items (`li`).
*   **Emmet for List Items:** Use the nesting operator (`>`) and the multiplication operator (`*`) to generate multiple list items quickly (e.g., `ul>li*3`).

**Code Example:**

```html
<ul>
    <li>orange tea</li>
    <li>black tea</li>
</ul>
```
*   **Visual Representation:** Displays markers (dots).
*   **Meaning:** A list where the **order is not of much importance**. Example: A grocery item list (buying bread first or milk first does not matter).

#### C. Ordered List (`<ol>`)

*   **Shortcut:** `ol`.
*   **Visual Representation:** Automatically marked as numbers.
*   **Meaning:** There is an order; the **importance of the order is present**. Example: Cooking instructions (turning on the gas stove first, then boiling the water).

### IX. Understanding Content Flow

#### A. Block Level vs. Inline Elements

The difference in behavior (why some elements like `h1` and `h2` appear on separate lines, but `img` and `a` appear on the same line) is explained by the concepts of Block Level and Inline Elements.

##### 1. Block Level Elements

*   **Concept:** Block elements take up a "block".
*   **Behavior:** They go from **left to right**, consuming the entire block or territory of the browser. They consume the whole space.
*   **Examples of Block Level Elements:**
    *   Headings (`h1` to `h6`).
    *   Ordered Lists (`ol`).
    *   Unordered Lists (`ul`).
    *   List Items (`li`).
    *   Paragraphs (`p`).
    *   Container (`div`): A container or wrapper box that does not perform any other action.

##### 2. Inline Elements

*   **Concept:** Inline elements come "within the line".
*   **Behavior:** They go within the line and **do not consume or claim the territory of the entire block**. Multiple inline elements can be placed alongside each other.
*   **Examples of Inline Elements:**
    *   Anchor tags (`a` tags).
    *   Images (`img` or `imgs`).
    *   Strong tags (`strong`).
    *   Emphasis tags (`em`).

#### B. Identifying Element Type using Developer Tools

To find out whether an element is block level or inline:

1.  Use the Chrome browser.
2.  Right-click anywhere and click `inspect`.
3.  **Block Level:** When inspected, a yellowish/orangeish line goes **all the way from left to right**.
4.  **Inline Level:** When inspected, the element **does not go all the way from left to right**.

### X. Semantic vs. Visual Tags (Strong/B and Em/I)

HTML allows for different tags that produce the same visual result but carry different semantic meaning (used for accessibility and screen readers).

| Visual Effect | Visual Tag (Purely Visual) | Semantic Tag (Importance/Emphasis) | Semantic Difference |
| :--- | :--- | :--- | :--- |
| **Bold** | `<b>` (bold tag) | `<strong>` (strong tag) | `<strong>` means there is some strong emphasis and importance. `<b>` is just bold. |
| *Italicize* | `<i>` (italicize tag) | `<em>` (emphasis tag) | `<em>` ensures emphasis when a screen reader reads content out loud. `<i>` is just a fancy visual hierarchy display. |

**HTML's Goal:** HTML is all about laying down where the importance of the sentence, figure, or word is.

**Content Flow:** Tags like `strong`, `em`, `b`, and `i` are all **inline tags**. They do not consume the end-to-end space or create a new block on their own.

### XI. Conclusion

So far, the content covered includes: content, images, and lists. This is more than enough for this lecture.

In upcoming lectures, attributes, more important parts of HTML, forms, and elements that take input from the user will be studied. Lectures will continue to be longer, but fun.

### Code
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3.1.: Emmet, headings and block vs inline</title>
</head>
<body>
    <!-- Block Level Elements -->
    <h1>Lorem ipsum dolor sit amet.</h1>
    <h2>Lorem ipsum dolor sit amet consectetur.</h2>
    <h3>Lorem ipsum dolor sit amet consectetur adipisicing.</h3>
    <h4>Lorem, ipsum dolor sit amet consectetur adipisicing elit.</h4>
    <h5>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Officia?</h5>
    <h6>Lorem ipsum dolor sit amet consectetur adipisicing elit. Deserunt, libero.</h6>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Porro doloribus necessitatibus placeat, tempore amet a, vero facilis odio, velit iusto esse id magnam? Officia, earum eos? At ab error sint sed id libero non vel, officiis aliquam minus, eos illo optio! Quae, dolores autem ipsa doloremque tempora pariatur eum quod debitis quam beatae, cumque molestiae expedita esse libero quasi neque quisquam eveniet quidem exercitationem soluta repellat hic? Aperiam odio blanditiis nisi consequatur. Dicta voluptatibus facilis minima nulla veniam reiciendis! Ex provident voluptate tempore ab iure odio reiciendis sed dolores ea non, exercitationem cupiditate officia nesciunt magni maxime quasi veniam beatae voluptates quis quod laborum minima ullam. Debitis molestiae, nemo temporibus accusantium rem nulla sit neque ipsum voluptas harum odio eius quidem perferendis suscipit ad maiores earum illo quasi inventore dolores! Aperiam nam distinctio ut hic eaque omnis deserunt dolore blanditiis perspiciatis, non labore recusandae cupiditate? Beatae repellendus praesentium nostrum cum doloribus quas nobis maiores! Ipsa soluta ea tempore facilis necessitatibus eveniet cupiditate accusantium, minima dolore veniam quae maiores odit ratione eaque quam exercitationem! Vero voluptatibus iste autem numquam quos deserunt, laboriosam mollitia? Corrupti eligendi labore incidunt. Perferendis amet temporibus maxime non aut illo excepturi minima a! Expedita, quod! Laborum reprehenderit doloribus voluptate ipsa. Aperiam exercitationem quisquam deserunt accusantium omnis suscipit nobis nulla, ducimus laudantium ad reprehenderit obcaecati minus accusamus nisi incidunt distinctio optio eius qui animi, voluptas doloremque tenetur odit a. Qui, molestias neque? Natus ut error eos. Mollitia tempora accusantium nulla accusamus adipisci quo optio nam, nesciunt non repellendus.</p>
   
    <h1 title="Kya Dekh Raha hai Bhai">Don't Hover</h1>
    <ul>
        <li>dosa</li>
        <li>sambhar</li>
        <li>chutney</li>
    </ul>
    <ol>
        <li>momo</li>
        <li>chaowmein</li>
        <li>munchurian</li>
    </ol>
    <div>Hi</div>

    <!-- Inline Elements -->
    <img src="https://www.google.com/logos/doodles/2025/celebrating-idli-6753651837110862-2xa.gif" alt="Google Ext Link Image" width="500">
    <a href="https://en.wikipedia.org/wiki/P._Rajagopal_(businessman)">Dosa Sambhar Chutney</a>
    <a href="mailto:kintsugiprogrammer@gmail.com">Mail to</a>
    <a href="tel:1234567890">Call Me</a>
    <b>Bold</b>
    <em>Italics</em>
    <strong>Not Just Bold but strong Emphasis</strong>
</body>
</html>
```
![alt text](image.png)
![alt text](image-1.png)
---


---













---
# OTHERS
---
End-of-File

The [god-stack](https://github.com/kintsugi-programmer/god-stack) repository, authored by Kintsugi-Programmer, is less a comprehensive resource and more an Artifact of Continuous Research and Deep Inquiry into Computer Science and Software Engineering. It serves as a transparent ledger of the author's relentless pursuit of mastery, from the foundational algorithms to modern full-stack implementation.

> Made with üíö [Kintsugi-Programmer](https://github.com/kintsugi-programmer)